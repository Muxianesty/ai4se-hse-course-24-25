# Практическое задание на тему "Генерация имени функции по ее телу"

Выполнил: Литвинов Михаил Юрьевич, группа МСТПР241.

## Подготовка окружения

Как и было предложено, работа с проектом происходит посредством развертывания отдельного venv-окружения:

```shell
python3 -m venv venv
```

Далее требуется активировать окружение платформо-зависимым образом: например, на Windows это делается с помощью файла `venv/Scripts/activate.bat`.

Установка всех зависимостей производится:

```shell
python3 -m pip install -r requirements.txt
python3 -m pip install -r requirements_dev.txt
```

## Подзадача 1: Подготовка набора данных (ЯП Python)

См. файлы `funccraft/data.py` и `funccraft/python_funccraft.py`.

Подготовка набора данных производилась на первых `1000` элементах из выборки `test` из `code-search-net/code_search_net` для ЯП Python.
Для каждого элемента набора данных добавлялось три поля - `NEW_func_name`, `NEW_whole_func_string`, `NEW_docs_func_string`: извлеченные с помощью `tree_sitter` имя функции, ее тело с и без документирующих комментариев. Примеры обработки приведены для нескольких элементов с индексами `9`, `19`, `21`, `62` в файле `prepared-dataset/9-19-21-62.json`. Для определения того, является ли узел в AST комментарием, проверяется соответствие типа узла значению `comment` или значению `expression_statement` - во втором случае проверяется, содержит ли узел подстроку `"""` или `'''` (см. функцию `isComment` в `funccraft/python_funccraft.py`) с возможным префиксом `r`. 

Подготовка набора данных производится следующим образом:

```shell
python3 main.py prepare-data
```

## Подзадача 2: Использование предобученных моделей для предсказания имен функций (ЯП Python)

Для предсказаний используется предобученная модель [**CodeT5+**](https://huggingface.co/Salesforce/codet5p-220m), где для предсказания только лишь имени функции на ЯП Python к ее телу добавляется префикс `" def <extra_id_0> ():\n    "`.

### Использование исходного кода БЕЗ комментариев для предсказания имен функций

Предсказание производится следующим образом:

```shell
python3 main.py predict-names
```

По результатам нескольких запусков в среднем были получены следующие результаты:

```shell
********************************************************************************
Evaluation results:
{'exact_match': np.float64(0.136),
 'rouge1': np.float64(0.37454087301587313),
 'rouge2': np.float64(0.18650714285714284),
 'rougeL': np.float64(0.3727658730158733),
 'rougeLsum': np.float64(0.37279166666666674)}
********************************************************************************
```

### Использование исходного кода и комментариев к нему для предсказания имен функций

Предсказание производится следующим образом:

```shell
python3 main.py predict-names --full
```

По результатам нескольких запусков в среднем были получены следующие результаты:

```shell
********************************************************************************
Evaluation results:
{'exact_match': np.float64(0.205),        
 'rouge1': np.float64(0.4620582251082256),
 'rouge2': np.float64(0.2778170634920636),
 'rougeL': np.float64(0.4606462842712844),
 'rougeLsum': np.float64(0.4607925324675326)}
********************************************************************************
```

При задействовании документации в предсказании имен функций можно отметить улучшенные значения необходимых метрик.

## (Доп.) Подзадача 3: Подготовка набора данных и использование предобученных моделей для предсказания имен функций (ЯП Go)

В целях получения дополнительных результатов, действия из подзадач 1 и 2 были проделаны и для ЯП Go.

Для предсказания имен функций к их телам вместо префикса для ЯП Python добавлялся префикс `"func <extra_id_1> <extra_id_0>() "`.

### Подготовка набора данных

См. файлы `funccraft/data.py` и `funccraft/go_funccraft.py`.

Для ЯП Go процедура предобработки данных не отличалась от аналогичной для ЯП Python с точностью (невключительно) до типов узлов в соответствующих AST.

Подготовка набора данных производится следующим образом:

```shell
python3 main.py prepare-data --lang go
```

### Использование исходного кода БЕЗ комментариев для предсказания имен функций

Предсказание производится следующим образом (ЯП Go определяется автоматически из набора данных):

```shell
python3 main.py predict-names
```

По результатам нескольких запусков в среднем были получены следующие результаты:

```shell
********************************************************************************
Evaluation results:
{'exact_match': np.float64(0.043),
 'rouge1': np.float64(0.072),
 'rouge2': np.float64(0.0),
 'rougeL': np.float64(0.07216666666666666),
 'rougeLsum': np.float64(0.073)}
********************************************************************************
```

### Использование исходного кода и комментариев к нему для предсказания имен функций

Предсказание производится следующим образом (ЯП Go определяется автоматически из набора данных):

```shell
python3 main.py predict-names --full
```

По результатам нескольких запусков в среднем были получены следующие результаты:

```shell
********************************************************************************
Evaluation results:
{'exact_match': np.float64(0.042),
 'rouge1': np.float64(0.07466666666666666),
 'rouge2': np.float64(0.0),
 'rougeL': np.float64(0.07483333333333334),
 'rougeLsum': np.float64(0.075)}
********************************************************************************
```

При задействовании документации в предсказании имен функций можно отметить лишь незначительное улучшение метрики ROUGE - к сожалению, примеры на ЯП Go не содержали такое же количество полезных комментариев, как это было для ЯП Python.
